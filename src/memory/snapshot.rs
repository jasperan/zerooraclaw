//! Memory snapshot -- export/import core memories as human-readable Markdown.
//!
//! In the Oracle-only build, snapshots are handled differently:
//! - Oracle AI Database is the persistent store (no local brain.db)
//! - Export reads from Oracle and writes MEMORY_SNAPSHOT.md for Git visibility
//! - Hydration is a no-op (Oracle is always available; no cold-boot scenario)
//!
//! The snapshot parsing logic is preserved for backward compatibility with
//! existing MEMORY_SNAPSHOT.md files from pre-Oracle installations.

use anyhow::Result;
use std::fmt::Write;
use std::fs;
use std::path::{Path, PathBuf};

/// Filename for the snapshot (lives at workspace root for Git visibility).
pub const SNAPSHOT_FILENAME: &str = "MEMORY_SNAPSHOT.md";

/// Header written at the top of every snapshot file.
const SNAPSHOT_HEADER: &str = "# ZeroClaw Memory Snapshot\n\n\
    > Auto-generated by ZeroClaw (Oracle backend). Do not edit manually.\n\
    > This file provides Git-visible documentation of core memories stored in Oracle.\n\n";

/// Export snapshot -- currently a no-op stub.
///
/// In the Oracle-only build, snapshot export will query ZERO_MEMORIES for core
/// entries and write them to MEMORY_SNAPSHOT.md. This will be wired in Task 9.
pub fn export_snapshot(_workspace_dir: &Path) -> Result<usize> {
    tracing::debug!("snapshot export: Oracle backend -- stub (will be wired in Task 9)");
    Ok(0)
}

/// Hydrate from snapshot -- no-op in Oracle build.
///
/// Oracle is always-on persistent storage; there is no cold-boot hydration
/// scenario like with local SQLite.
pub fn hydrate_from_snapshot(_workspace_dir: &Path) -> Result<usize> {
    tracing::debug!("snapshot hydration: no-op in Oracle backend");
    Ok(0)
}

/// Check if we should auto-hydrate on startup.
///
/// Always returns `false` in the Oracle build -- Oracle is persistent.
pub fn should_hydrate(_workspace_dir: &Path) -> bool {
    false
}

/// Path to the snapshot file.
fn snapshot_path(workspace_dir: &Path) -> PathBuf {
    workspace_dir.join(SNAPSHOT_FILENAME)
}

/// Write a snapshot file from a list of (key, content) pairs.
///
/// This is a utility for code that assembles snapshot data from Oracle
/// queries or migration sources.
#[allow(dead_code)]
pub fn write_snapshot(workspace_dir: &Path, entries: &[(String, String)]) -> Result<()> {
    if entries.is_empty() {
        return Ok(());
    }

    let mut output = String::with_capacity(entries.len() * 200);
    output.push_str(SNAPSHOT_HEADER);

    let now = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    write!(output, "**Last exported:** {now}\n\n").unwrap();
    write!(output, "**Total core memories:** {}\n\n---\n\n", entries.len()).unwrap();

    for (key, content) in entries {
        write!(output, "### `{key}`\n\n").unwrap();
        write!(output, "{content}\n\n---\n\n").unwrap();
    }

    let path = snapshot_path(workspace_dir);
    fs::write(&path, output)?;

    tracing::info!(
        "Memory snapshot exported: {} entries -> {}",
        entries.len(),
        path.display()
    );

    Ok(())
}

/// Parse the structured markdown snapshot back into (key, content) pairs.
///
/// Supports both the old format (`### ðŸ”‘ \`key\``) and the new format (`### \`key\``).
pub fn parse_snapshot(input: &str) -> Vec<(String, String)> {
    let mut entries = Vec::new();
    let mut current_key: Option<String> = None;
    let mut current_content = String::new();

    for line in input.lines() {
        let trimmed = line.trim();

        // Match old format: ### ðŸ”‘ `key_name`  or new format: ### `key_name`
        let key_extracted = if trimmed.starts_with("### ðŸ”‘ `") && trimmed.ends_with('`') {
            trimmed
                .strip_prefix("### ðŸ”‘ `")
                .and_then(|s| s.strip_suffix('`'))
        } else if trimmed.starts_with("### `") && trimmed.ends_with('`') {
            trimmed
                .strip_prefix("### `")
                .and_then(|s| s.strip_suffix('`'))
        } else {
            None
        };

        if let Some(key) = key_extracted {
            // Save previous entry
            if let Some(prev_key) = current_key.take() {
                let content = current_content.trim().to_string();
                if !content.is_empty() {
                    entries.push((prev_key, content));
                }
            }

            if !key.is_empty() {
                current_key = Some(key.to_string());
                current_content = String::new();
            }
        } else if current_key.is_some() {
            // Skip metadata lines and separators
            if trimmed.starts_with("*Created:") || trimmed == "---" {
                continue;
            }
            // Accumulate content
            if !current_content.is_empty() || !trimmed.is_empty() {
                if !current_content.is_empty() {
                    current_content.push('\n');
                }
                current_content.push_str(line);
            }
        }
    }

    // Don't forget the last entry
    if let Some(key) = current_key {
        let content = current_content.trim().to_string();
        if !content.is_empty() {
            entries.push((key, content));
        }
    }

    entries
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn parse_snapshot_basic() {
        let input = r#"# ZeroClaw Memory Snapshot

> Auto-generated by ZeroClaw.

**Last exported:** 2025-01-15 14:30:00

**Total core memories:** 2

---

### `identity`

I am ZeroClaw, a self-preserving AI agent.

---

### `preference_lang`

The user prefers Rust for systems programming.

---
"#;

        let entries = parse_snapshot(input);
        assert_eq!(entries.len(), 2);
        assert_eq!(entries[0].0, "identity");
        assert!(entries[0].1.contains("self-preserving"));
        assert_eq!(entries[1].0, "preference_lang");
        assert!(entries[1].1.contains("Rust"));
    }

    #[test]
    fn parse_snapshot_legacy_format() {
        let input = "### ðŸ”‘ `identity`\n\nI am ZeroClaw.\n\n---\n";
        let entries = parse_snapshot(input);
        assert_eq!(entries.len(), 1);
        assert_eq!(entries[0].0, "identity");
    }

    #[test]
    fn parse_snapshot_empty() {
        let input = "# ZeroClaw Memory Snapshot\n\n> Nothing here.\n";
        let entries = parse_snapshot(input);
        assert!(entries.is_empty());
    }

    #[test]
    fn parse_snapshot_multiline_content() {
        let input = r#"### `rules`

Rule 1: Always be helpful.
Rule 2: Never lie.
Rule 3: Protect the user.

---
"#;

        let entries = parse_snapshot(input);
        assert_eq!(entries.len(), 1);
        assert!(entries[0].1.contains("Rule 1"));
        assert!(entries[0].1.contains("Rule 3"));
    }

    #[test]
    fn export_returns_zero_stub() {
        let tmp = TempDir::new().unwrap();
        let count = export_snapshot(tmp.path()).unwrap();
        assert_eq!(count, 0);
    }

    #[test]
    fn hydrate_returns_zero_stub() {
        let tmp = TempDir::new().unwrap();
        let count = hydrate_from_snapshot(tmp.path()).unwrap();
        assert_eq!(count, 0);
    }

    #[test]
    fn should_hydrate_always_false() {
        let tmp = TempDir::new().unwrap();
        assert!(!should_hydrate(tmp.path()));
    }

    #[test]
    fn write_and_parse_roundtrip() {
        let tmp = TempDir::new().unwrap();
        let entries = vec![
            ("identity".to_string(), "I am ZeroClaw".to_string()),
            ("preference".to_string(), "User likes Rust".to_string()),
        ];

        write_snapshot(tmp.path(), &entries).unwrap();

        let snapshot = tmp.path().join(SNAPSHOT_FILENAME);
        assert!(snapshot.exists());

        let content = fs::read_to_string(&snapshot).unwrap();
        let parsed = parse_snapshot(&content);
        assert_eq!(parsed.len(), 2);
        assert_eq!(parsed[0].0, "identity");
        assert_eq!(parsed[0].1, "I am ZeroClaw");
    }
}
